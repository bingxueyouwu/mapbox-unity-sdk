<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Included Examples | Mapbox SDK for Unity </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Included Examples | Mapbox SDK for Unity ">
    <meta name="generator" content="docfx 2.14.1.0">
    
    <link rel="shortcut icon" href="../docs/images/favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:newtab" content="true">
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../docs/images/mapbox-logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <h1 id="included-examples">Included Examples</h1>
              
<p>For each example, associated scripts and resources can be found in the same root directory as the scene itself.</p>
<h2 id="dynamiczoom-v120">DynamicZoom (v.1.2.0)</h2>
<p><em>DynamicZoom.unity</em></p>
<p>Go anywhere in the world!</p>
<p>This example demonstrates how to create a web-like map that loads tiles procedurally based on the (top-down) camera position. It features panning and zooming (using camera position and tile size). </p>
<h2 id="mapreload-v120">MapReload (v.1.2.0)</h2>
<p><em>MapReload.unity</em></p>
<p>This example demonstrates new <code>Initialize</code> functionality in <code>AbstractMap</code> and <code>AbstractMapVisualizer</code>. There is a <code>ReloadMap</code> component which can <code>Initialize</code> a map with a latitude/longitude and zoom level whenever the UI is refreshed (upon forward geocode search result or zoom slider changed). Additionally, a new concrete implementation of <code>AbstractMap</code>, <code>MapAtSpecificLocation</code>, is used to offset the map root position so that the precise latitude/longitude requested is at world origin. This provides a consistent map view even as the zoom level changes!</p>
<h2 id="lowpoly-v120">LowPoly (v.1.2.0)</h2>
<p><em>LowPoly.unity</em></p>
<p>This example uses a <code>LowPolyTerrainFactory</code> to facet terrain geometry. Essentially, vertices are not shared across faces and normals are <code>hard</code>. </p>
<h2 id="globe-v110">Globe (v.1.1.0)</h2>
<p><em>Globe.unity</em></p>
<p>This example uses a <code>GlobeTileProvider</code> to fetch the entire world bounds. Additionally, a <code>FlatSphereTerrainFactory</code> is used to spherically project terrain vertices to a sphere (radius).</p>
<p><strong>New in v1.2.0:</strong></p>
<ul>
<li>Added <code>DragRotate</code> component to spin the globe with mouse input.</li>
<li>Using <code>SpawnOnGlobeExample</code> component to demonstrate conversion of latitude/longitude to unity position on sphere.</li>
</ul>
<h2 id="terracedworld-v110">TerracedWorld (v.1.1.0)</h2>
<p><em>TerracedWorld.unity</em></p>
<p>This example uses the <code>mapbox.mapbox-terrain-v2</code> data layer with a <code>VectorTileFactory</code> to generate contoured terrain (also relevant: <code>HeightModifier</code> and <code>PolygonMeshModifier</code>).</p>
<h2 id="playground">Playground</h2>
<p>These examples demonstrate how to request specific Mapbox data using our C# library.</p>
<h4 id="forward-geocoder">Forward Geocoder</h4>
<p><em>ForwardGeocoder.unity</em></p>
<p>A forward geocoding request will fetch GeoJSON from a place name query. A new request is sent every time the user input field is edited.</p>
<p>Visit <a href="https://www.mapbox.com/api-documentation/#geocoding">our API documentation</a> for more information.</p>
<h4 id="reverse-geocoder">Reverse Geocoder</h4>
<p><em>ReverseGeocoder.unity</em></p>
<p>A reverse geocoding request will fetch GeoJSON from a location query. The location query string must be in the format of <code>latitude, longitude</code>. A new request is sent every time the user input field is edited.</p>
<p>Visit <a href="https://www.mapbox.com/api-documentation/#geocoding">our API documentation</a> for more information.</p>
<h4 id="directions">Directions</h4>
<p><em>Directions.unity</em></p>
<p>Enter a start location query (eg. &quot;San Francisco, CA&quot;), this is a forward geocode request.</p>
<p>Enter a destination query (eg. &quot;Los Angeles, CA&quot;), this is also a forward geocode request.</p>
<p>When the geocode requests have been completed, a directions request is executed. A new request is sent every time the start or destination user input fields are edited.</p>
<p>Directions results will be logged to the UI when they are available (in the form of JSON).</p>
<h4 id="raster-tile">Raster Tile</h4>
<p><em>RasterTile.unity</em></p>
<p>Uses a forward geocoder request to fetch a styled raster tile from a Map object. A new request is sent whenever the zoom or style are changed, or when the user input field is edited.</p>
<p>See: <a href="https://www.mapbox.com/help/define-style/">https://www.mapbox.com/help/define-style/</a></p>
<p>See: <a href="https://www.mapbox.com/api-documentation/#retrieve-raster-tiles-from-styles">https://www.mapbox.com/api-documentation/#retrieve-raster-tiles-from-styles</a></p>
<h4 id="vector-tile">Vector Tile</h4>
<p><em>VectorTile.unity</em></p>
<p>Uses a forward geocoder request to fetch GeoJSON from a vector tile. A new request is sent whenever the user input field is edited.</p>
<p>In this example, the result is GeoJSON with a feature collection.</p>
<p>Visit <a href="https://www.mapbox.com/api-documentation/#retrieve-features-from-vector-tiles">our API documentation</a> for more information.</p>
<h2 id="mesh-generation-basics">Mesh Generation Basics</h2>
<p><em>MeshGeneration.unity</em></p>
<p>This example demonstates the basics of the Mapbox Unity SDK <code>MapVisualization</code> framework. Specifically, <code>TerrainFactory</code>, <code>MapImageFactory</code>, and <code>MeshFactory</code> are used together to generate a layered map.</p>
<p><code>MapController</code> acts as the entry point. Here, you can specify the map center (<code>LatLng</code>) and range. Range <code>X</code>, <code>Y</code>, <code>Z</code>, <code>W</code> corresponds to the number of tiles (<code>int</code>) for North, East, South, and West, respectively.</p>
<p>See <code>TerrainFactory.asset</code> to customize the base ground mesh. This can either be <code>Flat</code> (no elevation), or modified with the <a href="https://www.mapbox.com/blog/terrain-rgb/">Mapbox Global Elevation Layer</a>. The <code>Resolution</code> property specifies how vertices each tile&#39;s generated plane will have. <strong>Note: this factory is needed if you plan to also use a <code>MapImageFactory</code> (for texture application purposes).</strong></p>
<p>See <code>MapImageFactory.asset</code> to customize the raster <code>MapId</code> you would like to use. Select <code>Custom</code> <code>Map Type</code> to use your own Mapbox Studio <code>Style URL</code>. </p>
<p>See <code>MeshFactory.asset</code> to see how specific layers are extracted from vector tiles. In this case, we are generating meshes for both <code>building</code> and <code>road</code>. Therefore, each layer has a <code>VectorLayerVisualizer</code> responsible for handling that layer&#39;s specific data (such as geometry).</p>
<h2 id="mesh-generataion-pois">Mesh Generataion Pois</h2>
<p><em>PoiGeneration.unity</em></p>
<p>With the exception of a <code>PoiVisualizer</code> (<code>PoiDemoPoiVisualizer</code>) being added to the <code>MeshFactory</code>, this example is identical to <code>Mesh Generation Basics</code>.</p>
<p><code>PoiDemoPoiVisualizer.asset</code> allows you to override which prefab to spawn for each <code>po_label</code> contained in the vector tile. This prefab should have a component that implements <code>ILabelVisualizationHelper</code> attached to it. This exists to inject feature data into (such as label and <code>Maki</code> icon).</p>
<p><strong>New in v1.0.0:</strong></p>
<ul>
<li>Added 3d POI objects in addition to the 2d POI objects to demonstrate that you can easily map latitude longitude to unity coordinates.</li>
</ul>
<h2 id="mesh-generation-styles">Mesh Generation Styles</h2>
<p><em>StylingDemoMeshGeneration.unity</em></p>
<p>This example demonstrates how to use <code>TypeFilters</code> to filter specific features for processing. In this case, we have chosen to exclude <code>schools</code> from mesh generation. Additionally, you can use <code>ModifierStacks</code> to further customize specific features (to color banks differently, for example).</p>
<p><strong>New in v1.1.0:</strong></p>
<ul>
<li>Using the <code>SpawnInsideModifier</code> to randomly distribute &quot;bushes&quot; inside of <code>park</code> <code>landuse</code> geometry (see <code>VectorLayerVisualizer</code>).</li>
</ul>
<p><strong>New in v1.2.0:</strong></p>
<ul>
<li>Buildings contain a <code>FeatureSelectionDetector</code> and a <code>HighlightFeature</code> to show how colliders can be used to select/interact with buildings and show vector feature data.</li>
<li>Added procedural prefab spawning inside <code>park</code> layer using <code>SpawnInsideModifier</code>.</li>
</ul>
<h2 id="drive">Drive</h2>
<p><em>Drive.unity</em></p>
<p>This example demonstrates how to utilize <a href="https://www.mapbox.com/vector-tiles/mapbox-traffic-v1/">Mapbox Traffic</a> and <a href="https://www.mapbox.com/api-documentation/#directions">Mapbox Directions</a> data within the Mapbox Unity SDK <code>MapVisualization</code> framework.</p>
<p><code>DirectionsHelper</code> is responsible for passing <code>Transform</code> positions to the <code>DirectionsFactory</code>, as waypoints, in the form of <code>Latitude/Longitude</code>.  You can use up to 25 waypoints. See <code>DriveDirectionFactory.asset</code> to analyze how the generated route is rendered.</p>
<p>Please see <code>DriveTrafficVisualizer.asset</code> to analyze how we styled low, moderate, heavy, and severe traffic congestion. Each congestion feature uses a <code>ModifierStack</code> to customize its generated appearance (such as height, width, and material/color).</p>
<p>The ground layer was generated with a <code>flat</code> <code>TerrainFactory</code> and a <code>MapImageFactory</code> (for raster tiles) with the Mapbox Dark style applied. </p>
<p>To understand 3D building generation, please see <code>Mesh Generation Basics</code>. One particular difference in this example, however, is the use of a <code>MergedModifierStack</code> for <code>DriveBuildingVisualizer.asset</code>. This <code>ModifierStack</code> is responsible for merging buildings during generation. This optimization reduces the number of transforms and draw calls in the scene, vastly improving the final frame rate.</p>
<h2 id="slippy-vector-terrain">Slippy Vector Terrain</h2>
<p><em>SlippyDemo.unity</em></p>
<p>This example demonstrates one way to create a <a href="http://wiki.openstreetmap.org/wiki/Slippy_Map">slippy map</a>. The <code>Slippy</code> component attached to the <code>MapController</code> game object is responsible for requesting new tiles as needed, based on the position of the camera relative to the map. This is achieved using <code>raycasting</code> and a dictionary of known (requested and fetched) tiles.</p>
<p>Use W, A, S, D keyboard controls to navigate the map at runtime.</p>
<p>Please see <code>Mesh Generation Basics</code> to understand how features are customized. </p>
<h2 id="voxels">Voxels</h2>
<p><em>VoxelWorld.unity</em></p>
<p>This Minecraft-inspired example demonstrates a less traditional way to consume Mapbox data for maps or world construction.</p>
<p><code>VoxelTile</code> is responsible for fetching both a styled raster tile and a <code>mapbox.terrain-rgb</code> (global elevation) tile. The styled raster pixels are sampled to determine which voxels to generate, via the <code>VoxelFetcher</code>. This is achieved using a <code>nearest color</code> formula. The elevation tile pixels are sampled to determine where to vertically place the voxels.</p>
<p><code>Zoom</code>: what <a href="http://wiki.openstreetmap.org/wiki/Zoom_levels">zoom level</a> to request the tiles at.</p>
<p><code>Elevation Multiplier</code>: use to exaggerate the real-world height.</p>
<p><code>Voxel Depth Padding</code>: determine how many voxels to spawn below the designated height. This helps fill holes in environments with extreme elevation variations.</p>
<p><code>Tile Width in Voxels</code>: How many voxels across each tile will generate. This will affect the detail of the world. Raster textures are downsampled according to this value.</p>
<p><code>Voxel Batch Count</code>: How many voxels to spawn at once. Keep this number low to prevent locking the main thread during construction. </p>
<p>Please read <a href="https://www.mapbox.com/blog/how-to-minecraft-unity/">the blog post</a> describing how this was made for more information. </p>
<h2 id="locationprovider">LocationProvider</h2>
<p><em>LocationProvider.unity</em></p>
<p>This example is to demonstrate how to:</p>
<ul>
<li>Build a map for your current (device) location </li>
<li>Update a virtual player&#39;s position and rotation based on a real or mock location and heading</li>
<li>Use mock location providers to test in the Unity editor</li>
<li>Convert between unity world space&lt;—&gt;earth space (latitude, longitude)</li>
</ul>
<p>The <code>LocationProvider</code> game object in this scene has three children. Each child corresponds to a specific type of <code>ILocationProvider</code>. Please <a href="https://mapbox.github.io/mapbox-unity-sdk/api/unity/Mapbox.Unity.Location.html">read more about LocationProviders</a>.</p>
<p>The <code>MapController</code> game object has a <code>BuildMapAtLocation</code> component attached to it. This component is responsible for overriding the default center point of the <code>MapController</code> component, using the DefaultLocationProvider&#39;s location. In the Unity editor, this is the <code>EditorLocationProvider</code>—intended for mocking. On device, this is the <code>DeviceLocationProvider</code>—intended for real world location updates.</p>
<p>To change the location for the map in the Editor, change <code>EditorLocationProvider</code>&#39;s <code>LatitudeLongitude</code> field on the <code>Editor</code> game object. You can use the embedded <code>Search</code> button in the inspector to search for a place or address. The default location for this scene is the Metreon, in San Francisco, CA. </p>
<p><strong>Note: It is important that the <code>MapController</code> component be disabled to begin with.</strong></p>
<p>Press play and observe the map being constructed. Click on the <code>Player</code> game object and note the attached components: <code>PositionWithLocationProvider</code> and <code>RotateWithLocationProvider</code>. These are responsible for updating the transform&#39;s position and rotation based on a specified <code>ILocationProvider</code>. Again, in the <code>EditorLocationProvider</code>, search for <code>Yerba Buena Gardens</code> and select the top result. Watch as the player&#39;s position updates!</p>
<p>If you check <code>Use Transform Location Provider</code> for <code>PositionWithLocationProvider</code> and <code>RotateWithLocationProvider</code>, the mock <code>ILocationProvider</code> will be represented by the <code>Transform</code> game object. Press play once more with this toggle checked for both components. In the scene view, move and rotate the <code>Transform</code> game object and observe as the <code>Player</code> tries to follow that target. It is important to note that the location returned by the <code>TransformLocationProvider</code> is actually converted from the transform&#39;s world position to latitude, longitude. This is what that conversion looks like: </p>
<pre><code class="lang-cs">return _targetTransform.GetGeoPosition(MapController.ReferenceTileRect.Center, MapController.WorldScaleFactor);
</code></pre><p>If you build to device, you should see a familiar map and can observe the player update with your own location. Because the camera is a child of <code>Player</code>, you should always be centered on the map.</p>
<p><strong>New in v1.2.0:</strong></p>
<ul>
<li>Map initialization happens now with the <code>InitializeMapWithLocationProvider</code> component, rather than on awake or through a custom map builder. This is a more modular approach.</li>
<li>TileProvider has been replaced with <code>RangeAroundTransformTileProvider</code> which will dynamically load tiles as the player avatar is updated with location data.</li>
</ul>

            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/mapbox/mapbox-unity-sdk/blob/develop/documentation/docs/03-examples.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            &#0169; 2017 Mapbox
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
